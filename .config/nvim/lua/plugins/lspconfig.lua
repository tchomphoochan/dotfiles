--[[
  This file was generated by ChatGPT from the following prompt:

  "Configure nvim-lspconfig for C projects to:
    - Automatically detect project root based on compile_commands.json, Makefile, or .git
    - Prefer using compile_commands.json if available
    - Otherwise, if Makefile exists, dry-run 'make -n' synchronously to detect -I (include) and -D (define) flags
    - Fallback to recursively finding all directories containing header files (.h, .hpp, .hxx) under the project root
    - Allow runtime switching between 'make', 'treewalk', and 'none' detection modes, with dynamic detection if 'auto' selected
    - Restart clangd when mode changes if needed
    - Cache scanned results during the Neovim session
    - Normalize all include paths to absolute paths relative to root
    - Deduplicate include and define flags
    - Display make errors if make fails during explicit make mode (cleanly formatted)
    - Provide <leader>li to list project include dirs and defines
    - Provide <leader>lr to manually restart clangd"

  Notes:
    - This file configures *only* 'nvim-lspconfig', using lazy.nvim conventions.
    - If you modify or regenerate it, please update the prompt documentation at the top.
]]

return {
  "neovim/nvim-lspconfig",
  config = function()
    local lspconfig = require("lspconfig")
    local util = require("lspconfig.util")

    local cached_project_info = {}
    local project_modes = {}
    local valid_modes = { make = true, treewalk = true, none = true }

    -- === Helper functions ===

    local function safe_systemlist(cmd, cwd)
      local old_dir = vim.fn.getcwd()
      vim.cmd("cd " .. vim.fn.fnameescape(cwd))
      local output = vim.fn.systemlist(cmd)
      vim.cmd("cd " .. vim.fn.fnameescape(old_dir))
      return output or {}
    end

    local function get_root_dir()
      return util.root_pattern("compile_commands.json", "compile_flags.txt", "Makefile", ".git")(vim.api.nvim_buf_get_name(0))
    end

    local function restart_clangd()
      for _, client in ipairs(vim.lsp.get_clients({ bufnr = 0 })) do
        if client.name == "clangd" then
          client.stop()
        end
      end
      vim.cmd("edit")
    end

    local function format_make_error(output)
      local lines = {}
      for i, line in ipairs(output) do
        if i > 10 then
          table.insert(lines, "(more lines truncated)")
          break
        end
        table.insert(lines, line)
      end
      return table.concat(lines, "\n")
    end

    local function parse_flags(output, root_dir)
      local flags, seen = {}, {}
      for _, line in ipairs(output) do
        if line:match("gcc") or line:match("g++") or line:match("clang") or line:match("clang++") then
          local tokens = vim.fn.split(line)
          local i = 1
          while i <= #tokens do
            local token = tokens[i]
            if token:match("^%-I") then
              local path = token:sub(3)
              if not vim.startswith(path, "/") then
                path = vim.fn.fnamemodify(root_dir .. "/" .. path, ":p")
              end
              local flag = "-I" .. path
              if not seen[flag] then
                seen[flag] = true
                table.insert(flags, flag)
              end
            elseif token == "-D" then
              i = i + 1
              local macro = tokens[i]
              if macro and not seen["-D" .. macro] then
                seen["-D" .. macro] = true
                table.insert(flags, "-D" .. macro)
              end
            elseif token:match("^%-D") then
              if not seen[token] then
                seen[token] = true
                table.insert(flags, token)
              end
            end
            i = i + 1
          end
        end
      end
      return flags
    end

    local function scan_headers(root_dir)
      local uv = vim.loop
      local header_dirs, flags, seen = {}, {}, {}

      local function scan(dir)
        local handle = uv.fs_scandir(dir)
        if not handle then return end
        while true do
          local name, typ = uv.fs_scandir_next(handle)
          if not name then break end
          local full_path = dir .. "/" .. name
          if typ == "directory" then
            scan(full_path)
          elseif typ == "file" then
            if name:match("%.h$") or name:match("%.hpp$") or name:match("%.hxx$") then
              header_dirs[dir] = true
            end
          end
        end
      end

      scan(root_dir)

      for dir, _ in pairs(header_dirs) do
        local path = vim.fn.fnamemodify(dir, ":p")
        local flag = "-I" .. path
        if not seen[flag] then
          seen[flag] = true
          table.insert(flags, flag)
        end
      end
      return flags
    end

    local function detect_project_info(root_dir)
      if not root_dir then return { flags = {}, source = "unknown", root = "unknown" } end
      if cached_project_info[root_dir] then
        return cached_project_info[root_dir]
      end

      local mode = project_modes[root_dir]
      local flags = {}
      local source = "treewalk"

      if not mode then
        local make_output = safe_systemlist("make -n", root_dir)
        if vim.v.shell_error == 0 then
          mode = "make"
        else
          mode = "treewalk"
        end
        project_modes[root_dir] = mode
      end

      if mode == "none" then
        cached_project_info[root_dir] = { flags = {}, source = "none", root = root_dir }
        return cached_project_info[root_dir]
      elseif mode == "make" then
        local make_output = safe_systemlist("make -n", root_dir)
        if vim.v.shell_error ~= 0 then
          vim.notify("Explicit make mode failed.\n" .. format_make_error(make_output), vim.log.levels.ERROR)
          flags = scan_headers(root_dir)
          source = "treewalk (fallback)"
        else
          flags = parse_flags(make_output, root_dir)
          source = "make"
        end
      elseif mode == "treewalk" then
        flags = scan_headers(root_dir)
        source = "treewalk"
      end

      cached_project_info[root_dir] = { flags = flags, source = source, root = root_dir }
      return cached_project_info[root_dir]
    end

    local function format_flags(project_info)
      local flags, includes, defines = project_info.flags or {}, {}, {}
      local seen_includes, seen_defines = {}, {}

      for _, flag in ipairs(flags) do
        if flag:match("^%-I") then
          local inc = flag:gsub("^-I", "")
          if not seen_includes[inc] then
            seen_includes[inc] = true
            table.insert(includes, inc)
          end
        elseif flag:match("^%-D") then
          local def = flag:gsub("^-D", "")
          if not seen_defines[def] then
            seen_defines[def] = true
            table.insert(defines, def)
          end
        end
      end

      local lines = {
        "Root: " .. (project_info.root or "unknown"),
        "Source: " .. (project_info.source or "unknown"),
      }

      if #includes > 0 then
        table.insert(lines, "\nInclude Directories:")
        vim.list_extend(lines, includes)
      end
      if #defines > 0 then
        table.insert(lines, "\n\nPreprocessor Defines:")
        vim.list_extend(lines, defines)
      end

      return table.concat(lines, "\n")
    end

    -- === User commands ===

    vim.api.nvim_create_user_command("ProjectMode", function(opts)
      local mode = opts.args
      local root_dir = get_root_dir()
      if not root_dir then
        vim.notify("No project root found for current buffer.", vim.log.levels.ERROR)
        return
      end

      if mode == "auto" then
        local make_output = safe_systemlist("make -n", root_dir)
        if vim.v.shell_error == 0 then
          mode = "make"
          vim.notify("Auto-detected project mode: make")
        else
          mode = "treewalk"
          vim.notify("Auto-detected project mode: treewalk")
        end
      elseif not valid_modes[mode] then
        vim.notify("Invalid mode: must be 'make', 'treewalk', 'none', or 'auto'", vim.log.levels.ERROR)
        return
      end

      project_modes[root_dir] = mode
      cached_project_info[root_dir] = nil
      vim.notify("Project mode for " .. root_dir .. " set to " .. mode)
      restart_clangd()
    end, { nargs = 1 })

    -- === LSP Config ===

    lspconfig.clangd.setup({
      root_dir = util.root_pattern("compile_commands.json", "compile_flags.txt", "Makefile", ".git"),
      cmd = { "clangd", "--query-driver=**" },
      on_new_config = function(new_config, new_root_dir)
        local project_info = detect_project_info(new_root_dir)
        new_config.init_options = {
          fallbackFlags = vim.deepcopy(project_info.flags)
        }
        new_config._project_info = project_info
      end,
      on_attach = function(client, bufnr)
        vim.keymap.set("n", "<leader>li", function()
          local root_dir = get_root_dir()
          local project_info = detect_project_info(root_dir)
          vim.notify(format_flags(project_info), vim.log.levels.INFO, { title = "Project Compilation Flags" })
        end, { buffer = bufnr, desc = "List project compilation flags" })

        vim.keymap.set("n", "<leader>lr", function()
          restart_clangd()
        end, { buffer = bufnr, desc = "Restart clangd for current buffer" })
      end,
    })

    vim.diagnostic.config({
      update_in_insert = true,
      float = {
        focusable = false,
        style = "minimal",
        border = "rounded",
        source = "always",
        header = "",
        prefix = "",
      }
    })
  end
}


